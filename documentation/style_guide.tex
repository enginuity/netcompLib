\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{todonotes}

\newcommand{\codefilestatus}[3]{\begin{itemize}
\item Last Updated: #1
\item Documented? #2
\item Standardized Parameterization? #3
\end{itemize}}

\begin{document}


\title{Documentation for netcomplib}

\maketitle
\tableofcontents
\pagebreak

\listoftodos

\pagebreak

\section{Introduction}

This is a collection of functions that perform hypothesis testing using random edge partitions. \todo{add more to introduction}


\section{Usage Information}
\todo{Write general use case function} -- In general, to simply use the hypothesis testing function, one only needs to input the adjacency matrices (or perhaps arrays). A function for this process hasn't been written yet (only simulation functions that do this a number of times has been written). \\

To use the other pieces of the program for whatever use case: \\

\todo{add no indentation}
Models (eg. SBM or HRGs) can be stored as classes (or a random model can be generated and stored in a class). See the section \todo{link this} to see the documentation on the available classes and the structure. \\

There are some generic functions that work on models, described in the section on Functions \todo{link this}. They perform various tasks, and are almost all used for doing the hypothesis test. \\

\section{Functions}
These functions often take in as parameters some complex classes/list structures that are better documented in the package documentation \todo{add here?}. A brief table follows as a guide to function parameters. \\

\begin{tabular}{|l|l|p{8cm}|} \hline
{\bf Parameter Name} & {\bf Object Type} & {\bf Description} \\ 
\hline
NetM & class & Fully specifies a single network model \\ \hline
NetS & class & Fully specifies a random edge partition \\ \hline
param\_list OR pl & list & List of parameters for simulation (or for specifying details for testing) \\ \hline
model\_param & list & List of parameters to generate a single network model or random edge partition\\ \hline 
\end{tabular}




\subsection{Functions}


\subsubsection{Functions}
\begin{itemize} 
\item getNnodes(NetM)\\
This returns the number of nodes in the network
\item getNetType(NetM)\\
This returns the type of network model
\item getEdgeProbMat(NetM, mode))\\
This computes the edge probability matrix\\
Mode = `prob' or `group', will return either a probability matrix or a matrix with ids for group assignment. 
\item sampleNetwork(NetM, Nobs, Nsim)\\
This samples networks from the model
\item extractStruct(NetM)
This converts the network model into a structure object (basically, throws out probability information)
\item computeLik(NetM, adja, loglik = TRUE)\\
This computes the likelihood of the adjacency matrix given the network model. loglik specifies whether we want the log-likelihood or the actual likelihood
\item computeDist(x, y = NULL) \\
Not implemented yet -- Computes the KL distance between two network models (x,y)

\item getNnodes(Net)
\item getNetType(Net)
\item fitModel(NetS, adja)\\
Not implemented -- This fits the model to the adjacency matrix/array, and returns the best fit (MLE) network model. 
\item computePval(NetS, adja1, adja2, Nobs, pl)\\
Returns a matrix of p-values (based on the parameter list) of fitting the model on the given NetS (or, list of NetS's, in which case a list of matrices is returned)
\item computePval\_fast(...)\\
Not implemented -- perhaps write a faster version of this (using global variables, and thus only callable in a very specific manner), as the current code might be slow (due to R's pass by copy as opposed to reference) -- this should end up being written in C++... 
\end{itemize}


\subsection{Classes}

\subsubsection{NetworkModel}
\begin{itemize}
\item NetworkModel (Abbreviated NetM)\\
FIELD -- Nnodes : numeric
\begin{itemize}
\item NetworkModelSBM\\
FIELD -- assign : numeric \\
FIELD -- probmat : matrix\\
\item NetworkModelHRG\\
FIELD -- parents : numeric\\
FIELD -- children : list\\
FIELD -- prob : numeric\\
\item NetworkModelLSM\\
FIELD -- locs : matrix\\
FIELD -- alpha : numeric\\
\item NetworkModelRND\\
FIELD -- counts : numeric\\
FIELD -- prob : numeric\\
FIELD -- ids : list\\
\item NetworkModelPair\\
FIELD -- m1 : NetworkModel\\
FIELD -- m2 : NetworkModel\\
FIELD -- is\_null : logical\\
FIELD -- model\_type : character -- Allowed values:
\begin{itemize}
\item `default'
\item `densitydiff'
\item `correlated' -- not implemented -- {\bf TODO}
\end{itemize}
FIELD -- addl\_param : named list -- Entries: 
\begin{itemize}
\item dd\_param\_add : numeric = added parameter for log-odds addition
\end{itemize}
\end{itemize}
\end{itemize}

\subsubsection{NetworkStruct}
\begin{itemize}

\item NetworkStruct (Abbreviated NetS)\\
FIELD -- Nnodes : numeric
\begin{itemize}
\item NetworkStructSBM\\
FIELD -- groups : numeric\\
FIELD -- counts : numeric\\
FIELD -- expand : list\\
FIELD -- correct : numeric\\
\item NetworkStructHRG\\
FIELD -- tree\_list : list\\
FIELD -- expand : list\\
FIELD -- counts : numeric\\
\item NetworkStructRND\\
FIELD -- counts : numeric\\
FIELD -- ids : list\\
\item NetworkStructList\\
FIELD -- models : list\\
\end{itemize}
\end{itemize}












\section{Programming Notes}



\section{TODOS to add as issues:}
\begin{itemize}
\item Add dependencies into package -- 'abind' for function 'abind', and 'faraway' for functions 'logit', 'ilogit'
\item Check if 'logit' function in package 'gtools' is better
\item Document computeDfAdj properly -- seems to work, check if it works
\item Work on simplifying simulation code: 
\begin{itemize}
\item put model type inside of setmodelparam
\item generalizeble to list of genmodel and list of fit parameters -- do expand.grid of combinations
\item include pvalue adjustment as a setsimparam?
\end{itemize}
\item in SBM.assign, reset this to 1:num-unique, and resize probmat appropriately
\item reassign-edgegroup-prob -- document this, and check: seems to work. 
\item TODO - allow by-group to emulate old faster code, or else need to adjust the simulation functions
\item Write tests -- see if new code is reasonable
\item Check if the new compute\_pval works properly
\item Fix/document verbosity. 
\begin{itemize}
\item param 'verbose' = T/F - simple setting
\item param 'vbset' = (a,b,c) - a = number of functions (and calls) verbose; b = number of functions high-verbose; c = number of filler characters -- (eg +2 per sub function call)
\end{itemize}
\item Verbose logfile? -- so can output to file instead of terminal
\item Runtime estimation -- run 1\% of the process, and then estimate total runtime
\item Fix recycle\_fitstructs -- true means use max(n\_models). false means use sum(n\_models) -- generate list of indices, and store it in paramlist. when more models were generated; throw away the extras. 
\item Delete long processes inside computepval eventually -- for now, the settings are: 
\begin{itemize}
\item default - gives pval table using old code
\item chisq - only gives chisquare statistic
\item pvals - should give new version of default
\item nodal - gives list: chisq - chisquare stat, pvals - pval table, nodecontrib - nodal contributions
\end{itemize}
available model types: default, densitydiff, correlated, fast
\end{itemize}









\pagebreak

\section{OLD STUFF} 
\section{Standard Function Parameter Names}
Tables for the appropriate (consistent) parameter names









\subsection{General Parameters}
\begin{tabular}{|l|r|}
\hline
{\bf Object Type} & {\bf Parameter Names} \\


\hline
Num. Nodes in network & Nnodes \\

\hline
Num. Simulations & Nsim \\

\hline
Num. Network observation (pairs) & Nobs \\

\hline 
General Logging File	 & logfile \\

\hline
\end{tabular}



\subsection{Adjacency \& Probability Matrices}
\begin{tabular}{|l|r|}
\hline
{\bf Object Type} & {\bf Parameter Names} \\


\hline
Observed adjacency matrix (matrix) & obsadjm; obsadjm[k]; adjm[k];\\

\hline 
Observed adjacency matrices (array) & obsadjs; adja[k]; \\

\hline
Edge Probability Matrix (matrix) & epmat \\

\hline
\end{tabular}

\subsection{General Models}
\begin{tabular}{|l|r|}
\hline
{\bf Object Type} & {\bf Parameter Names} \\


\hline
HRG Model & tree; tree[k]; treel \\
\hline
Baseline (generating) model & btree; btree[k]; btreel \\
\hline
Fixed (estimating) model & ftree; ftree[k]; ftreel \\

\hline
\end{tabular}


\section{Object Types}
The following will be a description of different types of objects needed for different model classes and such

\subsection{Parameter Lists}
\subsubsection{Parameter List for Simulations}
\begin{itemize}
\item thres\_ignore = Edge groups with fewer than this many cells will be ignored
\item cc\_adj = Number of 'sd's away to be conservative with, regarding correlation estimate. 
\item alphas = Sizes of test to generate cutoffs for
\item n\_models = Number of fixed edge partitions to use

\end{itemize}

\pagebreak
\section{Programming Details}
\subsection{Documentation Guide}
\begin{verbatim}
Documentation rules -- For parameter listings in function documentation: 
@param <parameter> [<type>] :: <documentation>

<parameter> = parameter name
<documentation> = verbal description of usage of parameter
<type> = classification of parameter

Inside of <type>: 
, will separate information about parameters: eg. 
LEN = (length of vector) or 
DIM = (dimensions of matrix, etc.)
; will separate information about values the parameter takes on
DEFAULT = (default value) or
ALLOWED = (possibly a vector of allowed values)
OR = separates different possible types of paraemterization (or output)
- = identifies subtype of more general type of parameter

Example: 
[vector-int, LEN = 2; DEFAULT = c(1,2)] :: some description
list, matrix, array, vector
int, double, char, logical

For documentation of classes: (S3 classes)
an \itemize with items as follows: 
\item <name> -- [<mode description as above>] :: <documentation>

\end{verbatim}




\end{document}

