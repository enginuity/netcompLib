

#' Do simulations for the hypothesis testing, using the new code. 
#' 
#' @param gen_NetMPair [\code{\link{NetworkModelPair}}] :: Generating pair of models
#' @param fit_NetSList [\code{\link{NetworkStructList}}] :: List of fixed fitting structures (can be NULL -> randomly generate given parameters)
#' @param fitm_params [list] :: Output of \code{\link{set_model_params}}, specify the type of fitting model
#' @param adjm_list [list-list-array] :: Can input a list of adjacency matrices. Format is a list of list of pairs of arrays. The generating model pair will be ignored if this is provided. 
#' @param Nobs [int; DEFAULT = 1] :: Number network observations (default = 1)
#' @param Nsim [int; DEFAULT = 100] :: Number of simulations to do
#' @param pl [list; DEFAULT = \link{set_sim_param}()] :: Parameter list for testing procedure
#' @param verbose [logical] :: Output progress?
#' @param vbset [vector-int] :: passes along to \code{\link{computePval}}
#' 
#' @return [list] :: List of results ## TODO: Format of results?
#' 
#' @export
#' 
sim_hyptest = function(gen_NetMPair, fit_NetSList = NULL, fitm_params = set_model_param(), adjm_list = NULL, 
                       Nobs = 1, Nsim = 100, pl = set_sim_param(), verbose = TRUE, vbset = c(1,0,0)) {
  
  ## Set verbose parameters to pass into function calls
  vbset_new = vbset; vbset_new[1] = vbset[1] - 1; vbset_new[2] = vbset[2] - 1; vbset_new[3] = vbset[3] + 2;
  
  ## Check that enough models were generated
  if (is.null(fit_NetSList)) { 
    fit_NetSList = NetworkStructList(Nmodels = pl$struct_needed, model_params = fitm_params) 
  }
  if (pl$struct_needed != length(fit_NetSList@models)) { stop("Not enough fitted models generated") }
  
  ## Generate two lists of adjacency arrays if not provided
  if (is.null(adjm_list)) { adjm_list = sampleNetwork(gen_NetMPair, Nsim = Nsim) }
  
  
  ## Setup storage
  result_list = list(); for(f in seq_along(pl$pval_adj$fx)) { result_list[[f]] = list() } 
  pval_reslist = list()  

  ## Output progress message
  if (verbose & vbset[1] > 0) { cat("\n", stringr::str_pad(string = "", width = vbset[3], pad = "-"), date(), "-- Simulating Hypothesis Test") }  

  
  ## Do simulations
  for(j in 1:Nsim) {  
    ## Output progress
    if (verbose & vbset[1] > 0) { 
      if (j %% floor(Nsim / 10) == 0) { cat("\n", stringr::str_pad(string = "", width = vbset[3]+1, pad = "-"), date(), "-- Sim Number:", j) }
      if (vbset[2] > 0) { cat(".") }
    }
    
    ## Compute p-values
    pval_results = computePval(fit_NetSList, adja1 = adjm_list[[1]][[j]], adja2 = adjm_list[[2]][[j]], pl = pl, Nobs = 1, verbose = verbose, vbset = vbset_new)
#|----##Changed parameter 'mode' to 'output_mode' --Fri Feb 12 15:17:37 2016--
#|----##** MUST EDIT -- TODO -- Added model_type parameter --Thu Sep 17 03:10:20 2015--
    pval_reslist[[j]] = abind::abind(pval_results, along = 3)
    
    ## Insert extracted p-values
    for(f in seq_along(pl$pval_adj$fx)) {
      result_list[[f]][[j]] = setup_array(pl)
      for (k in seq_along(pl$n_structs)) {
        for (a in seq_along(pl$alphas)) {
          result_list[[f]][[j]][,,a,k] = apply(pval_reslist[[j]][,,pl$struct_indices[[k]], drop = FALSE], c(1,2),pl$pval_adj$fx[[f]])
        }
      }
    }
  }
  
  return(result_list)
}


#' Simulates critical values for each type of multiple testing adjustment
#' 
#' @param NetMPair [\code{\link{NetworkModelPair}}] :: Pair of network models: These serve as the 'null hypothesis' models from which to generate critical values from
#' @param Nsim [int; DEFAULT = 500] :: Number of simulations
#' @param Nobs [int; DEFAULT = 1] :: Number of network observations
#' @param fit_NetSList [\code{\link{NetworkStructList}}] :: A list of fitting structures. If NULL, an appropriate number of structures will be generated using input of fit_models_params
#' @param fit_models_params [list; DEFAULT = \code{\link{set_model_param}}()] :: parameter settings for fitted structures; this can be input instead of a list of pre-generated structures
#' @param pl [list] :: List of simulation parameters, typically generated by a call to set_sim_param()
#' @param verbose [int; DEFAULT = 0] :: Verbosity level, output stuff if > 2. 
#' @param vbset [vector-int] :: Passes to \code{\link{sim_hyptest}}; only iterates output headers -> passes exact same verbosity settings to \code{\link{sim_hyptest}}. 
#' 
#' @return [list] :: list of arrays of critical values
#' 
#' @export
#' 
sim_critvals = function(NetMPair, Nsim = 500, Nobs = 1, fit_NetSList = NULL, fit_models_params = set_model_param(), pl = set_sim_param(), verbose = 0, vbset = c(1,0,0)) { 
  vbset_new = vbset; vbset_new[1] = vbset[1]; vbset_new[2] = vbset[2]; vbset_new[3] = vbset[3] + 2;
  
  if (is.null(fit_NetSList)) {
    fit_NetSList = NetworkStructList(model_params = fit_models_params, Nmodels = pl$struct_needed)
  }
  
  if (verbose & vbset[1] > 0) { cat("\n", stringr::str_pad(string = "", width = vbset[3], pad = "-"), date(), "-- Simulating Critical Values: Calling sim_hyptest ***") }
  sim_vals = sim_hyptest(
    gen_NetMPair = NetMPair, fit_NetSList = fit_NetSList, 
    Nobs = Nobs, Nsim = Nsim, pl = pl, verbose = verbose, vbset = vbset_new)
  
  
  if (verbose & vbset[1] > 0) { cat("\n", stringr::str_pad(string = "", width = vbset[3], pad = "-"), date(), "-- Simulating Critical Values: Aggregating Results ***") }
  res_list = list()
  cases = expand.grid(pl[1:4])
  for(j in seq_along(pl$pval_adj$fx)) {
    res_list[[j]] = setup_array(pl)
    for(k in seq_len(nrow(cases))) {
      res_list[[j]][cases$cc_adj[k] == pl$cc_adj, 
                    cases$thres_ignore[k] == pl$thres_ignore,
                    cases$alphas[k] == pl$alphas, 
                    cases$n_structs[k] == pl$n_structs] = quantile(
                      sim_subsetresults(sim_vals[j], pl, 
                                        cases$cc_adj[k], cases$thres_ignore[k], cases$alphas[k], cases$n_structs[k]), probs = 1 - cases$alphas[k])
    }
  }
  return(res_list)
}


#' Create a named array matching a list
#' 
#' @param pl [list] :: List of simulation parameters, as given by \code{\link{set_sim_param}}()
#' 
#' @return [array] :: NA-filled named array
#' 
#' @export
#' 
setup_array = function(pl) {
  ## creates an array that names things properly
  if (!is.list(pl)) { stop("Input is not a list") }
  
  lengths = sapply(pl, length)[1:4]
  namelist = list()
  for (j in 1:4) {
    namelist[[names(pl)[j]]] = pl[[j]]
  }
  
  res = array(NA, dim = lengths, dimnames = namelist)
  return(res)
}


#' Extracts results matching a subset of parameters
#' 
#' @param rl [List] :: Should be output of sim_hyptest (or something similar) 
#' @param pl [List] :: List of simulation parameters, as given by set_sim_param()
#' @param cc_adj [int] :: Amount of SE's away from the correlation estimate used (how conservative? 0 means no adjustment (and requires large sample for guarantees; larger values give a conservative p-value))
#' @param thres_ignore [int] :: Ignore edge groups with fewer than this many edges
#' @param alphas [int] :: Size of test
#' @param n_structs [int] :: Number of edge partitions to use for testing
#' 
#' @return [matrix] :: A matrix of results of a certain type
#' 
#' @export
#' 
sim_subsetresults = function(rl, pl, cc_adj, thres_ignore, alphas, n_structs) { 
  i1 = which(pl$cc_adj == cc_adj)
  i2 = which(pl$thres_ignore == thres_ignore)
  i3 = which(pl$alphas == alphas)
  i4 = which(pl$n_structs == n_structs)
  
  res = matrix(-1, nrow = length(rl[[1]]), ncol = length(rl))
  for(j in seq_along(rl)) {
    res[,j] = sapply(rl[[j]], function(x) { x[i1, i2, i3, i4]} )
  }
  return(res)
}


## TODO: [Documentation-AUTO] Check/fix Roxygen2 Documentation (sim_power_rpart)
#' Simulates the power for different pairs of generating models
#' 
#' @param GL [list] :: List of generating models (NetModPairs)
#' @param NL [list] :: List of null-hypothesis models (NetModPairs)
#' @param FL [list] :: List of fitting model parameters
#' @param attrib [dataframe] :: Parameters of simulations
#' @param descrip [char] :: Description of simulation
#' @param outfile [char] :: Filename to store simulation results
#' @param Nsim [int; DEFAULT = 500] :: Number of simulations
#' @param Nsim_crit [int; DEFAULT = 500] :: Number of simulations for critical values
#' @param Nobs [int; DEFAULT = 1] :: Number of network observations
#' @param verbose [int; DEFAULT = 0] :: Verbosity level (from 0 to 3), larger means more output 
#' @param pl [list] :: List of simulation parameters, typically generated by a call to set_sim_param()
#' @param vbset temp
#' 
#' @return [list] :: List of power-simulation results
#' 
#' @export
#' 
sim_power_rpart = function(GL, NL, FL, attrib, descrip, outfile, Nsim = 500, Nsim_crit = 500, Nobs = 1, verbose = 0, pl = set_sim_param(), vbset = c(1,0,0)) {
  vbset_new = vbset; vbset_new[1] = vbset[1] - 1; vbset_new[2] = vbset[2] - 1; vbset_new[3] = vbset[3] + 4;
  
  ## TODO: [Update] fix implmenetation of parameter list; since set_sim_param has been updated. 
  
  ## then, will also need a function that helps generate the lists of models? maybe? 
  ## for simulations -- given a list of generating models, a list of null-hypothesis models (to generate crit values from), and a corresspnding list of fitting models: 
  
  ## for each pair, simulate the critical values
  ## then -- do simulation
  
  ## TODO: [Improve] Allow for output of p-values also. 
  
  
  ## input list of generating models is GL, null-hyp -> NL, fitting models -> FL
  
  if (length(GL) != length(NL) || length(NL) != length(FL)) { stop("The model lists are not compatible") }  
  power_list = list()
  cases = expand.grid(pl[1:4])
  
  ## Do simulations: 
  for (S in seq_along(GL)) {
    ## Generate network structures if necessary
    if (!is(FL[[S]], "NetworkStructList")) { FL[[S]] = NetworkStructList(pl$struct_needed, FL[[S]]) }
    
    ## Simulating critical values if necessary
    if (any(pl$pval_adj$simnull)) {
      if (verbose & vbset[1] > 0) { cat("\n", stringr::str_pad(string = "", width = vbset[3], pad = "-"), date(), "-- Simulation Number: ", S, " --- (Simulating Critical Values) =====", sep = "") }
      critvals = sim_critvals(NetMPair = NL[[S]], Nsim = Nsim_crit, Nobs = Nobs, fit_NetSList = FL[[S]], pl = pl, verbose = verbose, vbset = vbset_new)
    }
    
    ## Simulating pvalues
    if (verbose & vbset[1] > 0) { cat("\n", stringr::str_pad(string = "", width = vbset[3], pad = "-"), date(), "-- Simulation Number: ", S, " --- (Simulating Power) =====", sep = "") }
    sim_res = sim_hyptest(gen_NetMPair = GL[[S]], fit_NetSList = FL[[S]], Nobs = Nobs, Nsim = Nsim, pl = pl, verbose = verbose, vbset = vbset_new)
    
    
    ## Use critical values to reject if necessary
    if (verbose > 0) { cat("===== Simulation Number: ", S, " --- (Computing Power) =====\n", sep = "") }
    power_list[[S]] = list()
    
    for(j in seq_along(pl$pval_adj$fx)) {
      power_list[[S]][[j]] = setup_array(pl)
      for(k in seq_len(nrow(cases))) {
        i1 = which(cases$cc_adj[k] == pl$cc_adj); i2 = cases$thres_ignore[k] == pl$thres_ignore
        i3 = cases$alphas[k] == pl$alphas; i4 = cases$n_structs[k] == pl$n_structs
        
        test_stats = sim_subsetresults(sim_res, pl, cases$cc_adj[k], cases$thres_ignore[k], cases$alphas[k], cases$n_structs[k])
        
        if (names(pl$pval_adj$fx)[j] == "mult_bonferroni") {
          power_list[[S]][[j]][i1, i2, i3, i4] = mean(test_stats[,j] < 0.05 / cases$n_structs[k])
        } else {
          power_list[[S]][[j]][i1, i2, i3, i4] = mean(test_stats[,j] > critvals[[j]][i1, i2, i3, i4])
        }
      }
    }
    
    ## Save to file
    reslist = list(GL = GL, NL = NL, FL = FL, pl = pl, attrib = attrib, descrip = descrip, power = power_list)
    save(reslist, file = outfile)
  }
  
  return(reslist)
}


## TODO: [Update] this function to work with the new simulation functions

## TODO: [Documentation-AUTO] Check/fix Roxygen2 Documentation (extract_result_list)
#' Extracts p-values (or aggregated p-values) for a specific class of testing. 
#' 
#' @param full_output Full result list from sim_test
#' @param reslist Output from sim_power_rpart
#' @param cc_adj Value for correlation adjustment
#' @param thres_ignore Value for thresholding
#' @param alphas Size of test
#' @param n_structs Number of fixed models to use
#' @param raw_pvals T/F: Output raw p-values as a list? 
#' 
#' @return Vector of aggregated p-values (and a list of raw p-values if desired)
#' 
#' @export
#' 
extract_result_list = function(reslist, cc_adj = 2, thres_ignore = 5, alphas = 0.05, n_structs = 50, raw_pvals = FALSE) {
  ## TODO: [Improve] raw_pvals is broken
  
  rl = reslist$power
  pl = reslist$pl
  
  i1 = which(pl$cc_adj == cc_adj)
  i2 = which(pl$thres_ignore == thres_ignore)
  i3 = which(pl$alphas == alphas)
  i4 = which(pl$n_structs == n_structs)
  
  res = matrix(0, ncol = length(rl[[1]]), nrow = length(rl))
  colnames(res) = names(pl$pval_adj$fx)
  for(j in 1:length(rl)) {
    inl = rl[[j]]
    for(k in seq_along(inl)) {
      res[j,k] = inl[[k]][i1,i2,i3,i4]
    }
  }
  
  return(res)
}


